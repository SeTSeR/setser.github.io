# А что там с Rust в Linux?

В последний стабильный релиз ядра 6.1 заехала поддержка [модулей](https://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux.git/tree/samples/rust/rust_minimal.rs?h=v6.1&id=830b3c68c1fb1e9176028d02ef86f3cf76aa2476) на новомодном Rust. Я давно хотел на неё посмотреть, но подходящий момент подвернулся только сейчас. Она сразу была обозначена, как экспериментальная, так что больших ожиданий на этот счёт у меня не было. Я немного поэкспериментировал с этой поддержкой на нашем ядре на базе Linux 6.1 и увидел примерно следующее:

1.  Поддержка Rust конечно же опциональна. Она включается флагом `CONFIG_RUST`, который по умолчанию выключен и даже не показывается, если в системе нет тулчейна Rust;
2.  Основной поддерживаемый вариант сборки с модулями на Rust сейчас - сборка с помощью LLVM. Ядро же чаще всего с помощью GCC, где поддержку Rust только-только [запиливают](https://rust-gcc.github.io/);
3.  Ядру сейчас требуется вполне конкретная версия rustup/тулчейна, т. к. оно опирается на некоторые пока не стабилизированные аспекты языка. В ревизии, которая там запинена, нет, например, `rust-analyzer`, что бьёт по удобству разработки;
4.  Однако на самом деле это и не такая большая проблема: разрабатывать попросту нечего. Сейчас (т. е. в 6.1.6) из ядра в Rust выведены только самые базовые абстракции в виде модуля, кода ошибки `ENOMEM`, аллокатора и других вещей, необходимых, чтобы пример в начале заработал. Ничего сложнее сейчас, по всей видимости, написать нельзя.

Казалось бы, в чём проблема? Если нужна поддержка, возьми да и напиши, верно? Идея в общем-то неплохая, но сейчас пока непонятно даже, куда копать, чтобы, например, написать хотя бы драйвер, который будет генерировать фиктивный девайс со своим интерфейсом. А кто-нибудь из вас уже пробовал эту поддержку, может, расскажете чего интересного?
